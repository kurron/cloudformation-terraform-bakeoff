:toc:
:toc-placement!:

:note-caption: :information_source:
:tip-caption: :bulb:
:important-caption: :heavy_exclamation_mark:
:warning-caption: :warning:
:caution-caption: :fire:

= Terraform vs CloudFormation
Ron Kurr <rkurr@jvmguy.com>


toc::[]

== Overview
This is a very unscientific comparison between https://www.terraform.io/[Terraform] and https://aws.amazon.com/cloudformation/[AWS CloudFormation].  What we'll do is to implement a couple tasks in both tools and evaluate their strengths and weaknesses.

=== Tagging
Resource tagging is very important in AWS so we'll apply a common set of tags to all resources, calling out any differences in tagging support that might exist.

=== VPC Creation
The first task is to create a new VPC that contains a public and private subnet for each availability zone in the region, an internet gateway, route tables, elastic ips and NAT gateways.

=== Bastion Box
SSH access must be done by proxying through a Bastion server.  Install a single EC2 instance of type t2.nano, restricting access to port 22 from a single ip address.  Create an auto scaling group that will ensure we always have at least one box up and running.  The auto scaling group should be configured to turn off the boxes after normal business hours. The instance should be based on the currently release Amazon Linux AMI.

=== ECS Cluster
Create an ECS cluster using Spot Instances of type m4.large installed into the private subnets.  Create a public facing load balancer that routes traffic to the ECS work loads.  Construct the security groups so that only the Bastion boxes and load balancer can connect to the instances.  Create an auto scaling group that will ensure we always have at least 2 boxes up and running.  The auto scaling group should be configured to turn off the boxes after normal business hours. The SSH key for the cluster should be the same one that the Bastion box uses.  The necessary IAM resources and CloudWatch Log Groups should also be created.  The log balancer's access logs should be saved in a S3 bucket that ages out the files after 1 week.

=== Deploy An ECS Service
Deploy 3 containers to the ECS cluster, spreading the work load so each node gets one instance.  The load balancer should be configured so that the `/echo` path gets mapped to the containers.  The load balancer should be configured to issue health checks, removing any sick containers as they are detected. RAM and CPU limits should be placed on the containers.  The containers should be configured to publish log messages to CloudWatch Logs.

=== Update The ECS Service
Change the number of desired containers instances up or down by 1. The goal is to see how each tool handles changes to the infrastructure.

=== Create the entire stack using modules
Normally, you don't want to define your entire stack in a single file.  Instead, you want to compose the stack out of smaller modules which have already been tested.  Create the entire stack using a modular approach.

== Prerequisites

* an https://aws.amazon.com/[AWS] account
* an SSH client
* https://www.terraform.io/[Terraform] installed and working
* https://aws.amazon.com/cli/[AWS CLI] installed and working
* https://www.gnu.org/software/bash/[BASH] installed and working
* AWS API keys exported to the Environment

```bash
export AWS_ACCESS_KEY_ID="some-key"
export AWS_SECRET_ACCESS_KEY="some-access-key"
export AWS_DEFAULT_REGION="us-east-2"
```

== Building
There isn't anything to build for this project.

== Installation
There isn't anything to install but you will need to run the `copy-files-to-s3.sh` script prior to running the `composability` script in the `terraform` directory.  Make sure to edit `copy-files-to-s3.sh` to use a unique bucket name. Using the existing bucket name will result in failures.

== Tips and Tricks
=== Terraform Scripts
The Terraform modules all work the same so these instructions apply to all modules.  Prior to testing a module, you will need to edit the `debug/backend.cfg` to point to an S3 bucket you have previously created to store Terraform's state.  The current values are set to a bucket you will not have access to.

```
bucket = "your-bucket-name"
region = "us-east-1"
key    = "us-east-2/debug/networking/vpc/terraform.tfstate"
```

To change values for a module, edit `debug/plan.tf`. For example, to change some of the values used for tagging, you might make edits to this:

```
module "vpc" {
    source = "../"

    region             = "us-east-2"
    name               = "Terraform"
    project            = "Bake Off"
    purpose            = "Terraform vs CloudFormation comparison"
    creator            = "rkurr@jvmguy.com"
    environment        = "development"
    freetext           = "One public and private subnet in each AZ."
    cidr_range         = "10.0.0.0/16"
    private_subnets    = ["10.0.1.0/24","10.0.3.0/24","10.0.5.0/24"]
    public_subnets     = ["10.0.2.0/24","10.0.4.0/24","10.0.6.0/24"]
    populate_all_zones = "false"
}
```

To actually build infrastructure, run `debug/debug-module.sh`.  The script exercises the 5 main Terraform commands:

1. `terraform init`, which initializes the module by downloading any dependencies it needs
1. `terraform plan`, which compares what you want done to what is currently in AWS
1. `terraform show`, which is used for peer reviews so proposed changes can evaluated prior to execution
1. `terraform apply`, which executes the plan, manipulating resources in AWS to match the plan
1. `terraform destroy`, which tears down any infrastructure that the module created. You can type `NO` to leave the infrastructure in place.

Terraform is idempotent so you can run the script several times in a row and nothing will change.

=== CloudFormation Scripts
The CloudFormation modules all work the same so these instructions apply to all modules.  Run `scripts/validate-stack.sh` to have the stack's YAML file validated for obvious syntax errors.  `scripts/create-stack.sh` will create the stack but you probably have to edit it prior to execution in order to get the values correct.  Unlike Terraform, CloudFormation doesn't support inter-module sharing of information so you have to copy and paste ids from previous modules.  For example, assume that we've already run the `vpc` module and have an empty VPC.  We need to edit the `create-stack.sh` script in the `bastion` folder and paste in the values it needs from the VPC module.

```BASH
STACKNAME=${1:-Bastion}
PROJECTNAME=${2:-BakeOff}
ENVIRONMENT=${3:-development}
CREATOR=${4:-CloudFormation}
CIDR=${5:-50.235.141.198/32}
VPC=${6:-vpc-7fc69a17}
SUBNETS=${7:-subnet-28b9fb40,subnet-70a3180a,subnet-d716f49b}
TEMPLATELOCATION=${8:-file://$(pwd)/bastion.yml}
```
If you forget this step, the stack will fail because it won't recognize the VPC and subnet ids.

To remove resources, run `scripts/destroy-stack.sh`.

=== Module Execution Order
The modules build upon each other and need to be created in sequence for things to work correctly.

1. vpc
1. bastion
1. ecs
1. ecs-service
1. composability

== Troubleshooting

== Comparison
=== VPC Creation
Creating a VCP between the two tools is fairly similar.  Each makes you describe the various building blocks needed to construct a fully functional VPC and assemble them as needed.  Where they do differ is in the handling multiple instances of the same object.  For example, the scenario is to place  subnets into all availability zones of the region.  The Virgina region has 6 AZs while the Ohio region only has 3.  Terraform has a construct that allows you to build the same resource N number of times, saving on duplicated code.  CloudFormation does not provide anything similar so you have to duplicate the directives, increasing the amount of code and making the script less reusable.

NOTE: It has been awhile since I've scoured through the CloudFormation documentation looking for a "loop" construct but I suspect it still doesn't exist because the https://github.com/awslabs/aws-cloudformation-templates/blob/master/aws/services/ECS/EC2LaunchType/clusters/public-vpc.yml[AWS Samples] still repeat declarations for each subnet.

Another minor difference is that Terraform is command-line only while CloudFormation is GUI based.  Depending on the operator, this may be a differentiator.

NOTE: CloudFormation does have a command-line but it simply kicks off the process, requiring you to then monitor the job in the console.

Compare the source of the link:terraform/vpc/main.tf[Terraform version] to the link:cloudformation/vpc/vpc.yml[CloudFormation version] and see which you prefer.

=== Bastion Box
Creation of the Bastion box, complete with an auto scaling group, scheduled actions and a security group is a little easier using Terraform.  The reason for that is that https://www.terraform.io/docs/state/index.html[Terraform has a way to share state information] between modules.  This allows the VPC information I created in a previous step to be "imported" into the Bastion module.  In CloudFormation, VPC information has to be provided by the operator.  Another difference between the tools is that Terraform allows you to create a new SSH key pair but CloudFormation doesn't seem to have that support.  The operator has to create one prior via the console and feed the key pair name into CloudFormation.

Compare the source of the link:terraform/bastion/main.tf[Terraform version] to the link:cloudformation/bastion/bastion.yml[CloudFormation version] and see which you prefer.

=== ECS Cluster
Creation of an ECS custer, including a public load balancer, S3 bucket holding access logs and auto-scaling groups for the EC2 instances, are very similar between the tools.  One difference is that Terraform allows you to place tags on the EC2 instances that get spun up as part of the auto scaling action while CloudFormation does not, making it harder to identify instances.  Both systems were able to use spot instances for the EC2 boxes, cutting down on costs. Both systems allowed for construction of security groups so that the EC2 instances can only be accessed by the load balancer and Bastion boxes.

Compare the source of the link:terraform/ecs/main.tf[Terraform version] to the link:cloudformation/ecs/ecs.yml[CloudFormation version] and see which you prefer.

=== Deploy An ECS Service
Running a container on ECS is very similar between the two systems but Terraform does provide one interesting feature: templating.  When describing the task to be run in Terraform, you hand it a JSON descriptor.  Some of the values in the descriptor need to match what is specified in the module itself, otherwise things will not deploy properly.  Here is an example of the descriptor where I paramterized the CloudWatch Log Group to use when sending logs.  In a production system, I would have parameterized more, such as ports, paths and memory values.

```JSON
[
    {
        "name": "spring-cloud-echo",
        "image": "kurron/spring-cloud-aws-echo:latest",
        "cpu": 256,
        "memory": 256,
        "portMappings": [
            {
                "containerPort": 8080,
                "hostPort": 0,
                "protocol": "tcp"
            }
        ],
        "environment": [
            {
                "name": "server_context-path",
                "value": "/alpha"
            }
        ],
        "essential": true,
        "hostname": "spring-cloud",
        "disableNetworking": false,
        "logConfiguration": {
            "logDriver": "awslogs",
            "options": {
                "awslogs-region": "${region}",
                "awslogs-group": "${log_group}"
            }
        }
    }
]
```

In CloudFormation, I didn't use a separate descriptor and did everything inline:

```yml
TaskDefinition:
    Type: 'AWS::ECS::TaskDefinition'
    Properties:
        ContainerDefinitions:
            - Name:
                  Ref: ContainerName
              Environment:
                  - Name: server_context-path
                    Value: !Ref Path
                  - Name: management_context-path
                    Value: '/operations'
              Essential: true
              Image:
                  Ref: DockerImage
              LogConfiguration:
                LogDriver: awslogs
                Options:
                    awslogs-group:
                        Ref: ContainerLogGroup
                    awslogs-region:
                        Ref: AWS::Region
              Memory:
                  Ref: ContainerMemory
              PortMappings:
                - ContainerPort:
                    Ref: ContainerPort
        Family:
            Ref: ServiceFamily
        TaskRoleArn:
            Ref: AWS::NoValue
```
NOTE: I bring up templating only to note that CloudFormation does not appear to have the capability, but it could be that they don't ever expect you to need it.

Compare the source of the link:terraform/ecs-service/main.tf[Terraform version] to the link:cloudformation/ecs-service/service.yml[CloudFormation version] and see which you prefer.

=== Update The ECS Service
You can update a CloudFormation stack using a Change Set.  A change set is a description of how you want the stack to look and can be reviewed prior to application.  The most convenient manipulation of a change set is done via the AWS console but obviously cannot be automated. When automation is desired, the AWS CLI has to be used.  The CLI form, unfortunately, is more cumbersome because all parameters to the stack must be provided otherwise default values are used.  In the example below, only the `DesireCount` paramater is being changed but the other 19 parameters must also be referenced or you run the risk of changing the stack in unintended ways.

```bash
CREATE="aws cloudformation create-change-set --stack-name $STACK_ARN \
      	                                     --change-set-name $CHANGE_SET_NAME \
                                             --use-previous-template \
					     --parameters ParameterKey=DesiredCount,ParameterValue=$DESIRED_COUNT \
					                  ParameterKey=Project,UsePreviousValue=true \
					                  ParameterKey=Creator,UsePreviousValue=true \
					                  ParameterKey=Environment,UsePreviousValue=true \
					                  ParameterKey=Notes,UsePreviousValue=true \
					                  ParameterKey=VPC,UsePreviousValue=true \
					                  ParameterKey=Cluster,UsePreviousValue=true \
					                  ParameterKey=Listener,UsePreviousValue=true \
					                  ParameterKey=Path,UsePreviousValue=true \
					                  ParameterKey=HealthCheckPath,UsePreviousValue=true \
					                  ParameterKey=HealthCheckProtocol,UsePreviousValue=true \
					                  ParameterKey=LoadBalancerProtocol,UsePreviousValue=true \
					                  ParameterKey=LoadBalancerPort,UsePreviousValue=true \
					                  ParameterKey=ListenerPriority,UsePreviousValue=true \
					                  ParameterKey=DockerImage,UsePreviousValue=true \
					                  ParameterKey=ContainerPort,UsePreviousValue=true \
					                  ParameterKey=ContainerMemory,UsePreviousValue=true \
					                  ParameterKey=ContainerName,UsePreviousValue=true \
					                  ParameterKey=ServiceFamily,UsePreviousValue=true \
					                  ParameterKey=LogGroup,UsePreviousValue=true"
```
Terraform is more straight forward. All you do is edit the Terraform plan in-place, review the changes and then apply them.  Here is the output from bumping up the number of ECS container instances from 2 to 3:

```
terraform show debug/proposed-changes.plan
  ~ module.ecs_service.aws_ecs_service.service
      desired_count: "2" => "3"


terraform apply -refresh=true -lock=true -auto-approve=true -input=false debug/proposed-changes.plan
module.ecs_service.aws_ecs_service.service: Modifying... (ID: arn:aws:ecs:us-east-2:387188308760:service/Terraform)
  desired_count: "2" => "3"
module.ecs_service.aws_ecs_service.service: Modifications complete after 0s (ID: arn:aws:ecs:us-east-2:387188308760:service/Terraform)

Apply complete! Resources: 0 added, 1 changed, 0 destroyed.
```

Compare the source of the link:terraform/ecs-service/debug/plan.tf[Terraform version] to the link:cloudformation/ecs-service/scripts/update-stack.sh[CloudFormation version] and see which you prefer.

=== Create the entire stack using modules
Terraform has good story for this one. In fact, there is the https://registry.terraform.io/[Terraform Module Registry] where the community can share "recipes" for assembling different pieces of infrastructure.  The Terraform code we've used so far have been expressed in terms of modules so assembling them into a single file is straight forward.

CloudFormation has the notion of "nested stacks" where a master file imports and invokes the child modules.  Unlike Terraform, there isn't a registry of community modules.  All the files have to live in S3, which makes deployments a little less convenient and requires an additional step to continually move files from source control into a bucket.

Compare the source of the link:terraform/composability/debug/plan.tf[Terraform version] to the link:cloudformation/ecs-service/scripts/update-stack.sh[CloudFormation version] and see which you prefer.

== License and Credits
This project is licensed under the https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode[Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License].
