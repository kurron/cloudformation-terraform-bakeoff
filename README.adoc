:toc:
:toc-placement!:

:note-caption: :information_source:
:tip-caption: :bulb:
:important-caption: :heavy_exclamation_mark:
:warning-caption: :warning:
:caution-caption: :fire:

= Terraform vs CloudFormation
Ron Kurr <rkurr@jvmguy.com>


toc::[]

== Overview
This is a very unscientific comparison between https://www.terraform.io/[Terraform] and https://aws.amazon.com/cloudformation/[AWS CloudFormation].  What we'll do is to implement a couple tasks in both tools and evaluate their strengths and weaknesses.

=== Tagging
Resource tagging is very important in AWS so we'll apply a common set of tags to all resources, calling out any differences in tagging support.

=== VPC Creation
The first task is to create a new VPC that contains a public and private subnet for each availability zone in the region.

=== Bastion Box
SSH access must be done by proxying through a Bastion server.  Install a single EC2 instance of type t2.nano, restricting access to port 22 from a single ip address.  Create an autoscaling group that will ensure we always have at least one box up and running.  The autoscaling group should be configured to turn off the boxes after normal business hours.

=== ECS Cluster
Create an ECS cluster using Spot Instances of type M4.large installed into the private subnets.  Create a public facing load balancer that routes traffice to the ECS work loads.  Construct the security groups so that only the Bastion boxes and load balancer can connect to the instances.  Create an autoscaling group that will ensure we always have at least 2 boxex up and running.  The autoscaling group should be configured to turn off the boxes after normal business hours.

=== Deploy An ECS Service
Deploy a container so that each node in the cluster gets one instance.

=== Update The ECS Service
Change the number of desired containers instances up or down by 1.

=== Create the entire stack using modules
Normally, you don't want to define your entire stack in a single file.  Instead, you want to compose the stack out of smaller modules which have already been tested.  Create the entire stack using a modular approach.

== Prerequisites

* an https://aws.amazon.com/[AWS] account
* an SSH client
* familiarity with https://aws.amazon.com/ec2/[EC2]

== Building

== Installation

== Tips and Tricks

== Troubleshooting

== Comparison
=== VPC Creation
Creating a VCP between the two tools is fairly similar.  Each makes you describe the various building blocks needed to construct a fully functional VPC and assemble them as needed.  Where they do differ is in the handling multiple instances of the same object.  For example, the scenario is to place  subnets into all availability zones of the region.  The Virgina region has 6 AZs while the Ohio region only has 3.  Terraform has a construct that allows you to build the same resource N number of times, saving on duplicated code.  CloudFormation does not provide anything similar so you have to duplicate the directives, increasing the amount of code and making the script less reusable.

NOTE: It has been awhile since I've scoured through the CloudFormation documentation looking for a "loop" construct but I suspect it still doesn't exist because the https://github.com/awslabs/aws-cloudformation-templates/blob/master/aws/services/ECS/EC2LaunchType/clusters/public-vpc.yml[AWS Samples] still repeat declarations for each subnet.

Another minor difference is that Terraform is command-line only while CloudFormation is GUI based.  Depending on the operator, this may be a differentiator.

NOTE: CloudFormation does have a command-line but it simply kicks off the process, requiring you to then monitor the job in the console.

Compare the source of the link:terraform/vpc/main.tf[Terraform version] to the link:cloudformation/vpc/vpc.yml[CloudFormation version] and see which you prefer.

=== Bastion Box
Creation of the Bastion box, complete with an auto scaling group, scheduled actions and a security group is a little easier using Terraform.  The reason for that is that https://www.terraform.io/docs/state/index.html[Terraform has a way to share state information] between modules.  This allows the VPC information I created in a previous step to be "imported" into the Bastion module.  In CloudFormation, VPC information has to be provided by the operator.  Another difference between the tools is that Terraform allows you to create a new SSH key pair but CloudFormation doesn't seem to have that support.  The operator has to create one prior via the console and feed the key pair name into CloudFormation.  A final difference is how each tool deals with AMIs.  AMIs are specific to a region and Terraform has a function that can be used to search for that region's current AMI.  In CloudFormation, we have to manage an internal map of region to AMIs, which means the list can become stale.

NOTE: it is possible that AWS has added AMI lookup functionality but I haven't seen it yet.

Compare the source of the link:terraform/bastion/main.tf[Terraform version] to the link:cloudformation/bastion/bastion.yml[CloudFormation version] and see which you prefer.

=== ECS Cluster
Creation of an ECS custer, including a public load balancer, S3 bucket holding access logs and auto-scaling groups for the EC2 instances, are very similar between the tools.  One difference is that Terraform allows you to place tags on the EC2 instances that get spun up as part of the auto scaling action while CloudFormation does not, making it harder to identify instances.  Unlike the CloudFormation Bastion case, I was able to use a technique to lookup a the EC2 AMI to use for the cluster so we don't have to maintain an region-to-AMI mapping.  Both systems was able to use spot instances for the EC2 instances, cutting down on costs. Both systems allowed for construction of security groups so that the EC2 instances can only be accessed by the load balancer and Bastion boxes.

Compare the source of the link:terraform/ecs/main.tf[Terraform version] to the link:cloudformation/ecs/ecs.yml[CloudFormation version] and see which you prefer.

=== Deploy An ECS Service
Running a container on ECS is very similar between the two systems but Terraform does provide one interesting feature: templating.  When describing the task to be run in Terraform, you hand it a JSON descriptor.  Some of the values in the descriptor need to match what is specified in the module itself, otherwise things will not deploy properly.  Here is an example of the descriptor where I paramterized the CloudWatch Log Group to use when sending logs.  In a production system, I would have parameterized more, such as ports, paths and memory values.

```JSON
[
    {
        "name": "spring-cloud-echo",
        "image": "kurron/spring-cloud-aws-echo:latest",
        "cpu": 256,
        "memory": 256,
        "portMappings": [
            {
                "containerPort": 8080,
                "hostPort": 0,
                "protocol": "tcp"
            }
        ],
        "environment": [
            {
                "name": "server_context-path",
                "value": "/alpha"
            }
        ],
        "essential": true,
        "hostname": "spring-cloud",
        "disableNetworking": false,
        "logConfiguration": {
            "logDriver": "awslogs",
            "options": {
                "awslogs-region": "${region}",
                "awslogs-group": "${log_group}"
            }
        }
    }
]
```

In CloudFormation, I didn't use a separate descriptor and did everything inline:

```yml
Service:
    Type: 'AWS::ECS::Service'
    DependsOn: ListenerRule
    Properties:
        Cluster:
            Ref: Cluster
        DesiredCount:
            Ref: DesiredCount
        LoadBalancers:
            - ContainerName:
                  Ref: ContainerName
              ContainerPort:
                  Ref: ContainerPort
              TargetGroupArn:
                  Ref: PublicTargetGroup
        Role:
            Ref: AWS::NoValue
        TaskDefinition:
            Ref: TaskDefinition
```
NOTE: I bring up templating only to note that CloudFormation does not appear to have the capability, but it could be that they don't ever expect you to need it.

Compare the source of the link:terraform/ecs-service/main.tf[Terraform version] to the link:cloudformation/ecs-service/service.yml[CloudFormation version] and see which you prefer.

=== Update The ECS Service
You can update a CloudFormation stack using a Change Set.  A change set is a description of how you want the stack to look and can be reviewed prior to application.  The most convenient manipulation of a change set is done via the AWS console but obviously cannot be automated. When automation is desired, the AWS CLI has to be used.  The CLI form, unfortunately, is more cumbersome because all parameters to the stack must be provided otherwise default values are used.  In the example below, only the `DesireCount` paramater is being changed but the other 19 parameters must also be referenced or you run the risk of changing the stack in unintended ways.

```bash
CREATE="aws cloudformation create-change-set --stack-name $STACK_ARN \
      	                                     --change-set-name $CHANGE_SET_NAME \
                                             --use-previous-template \
					     --parameters ParameterKey=DesiredCount,ParameterValue=$DESIRED_COUNT \
					                  ParameterKey=Project,UsePreviousValue=true \
					                  ParameterKey=Creator,UsePreviousValue=true \
					                  ParameterKey=Environment,UsePreviousValue=true \
					                  ParameterKey=Notes,UsePreviousValue=true \
					                  ParameterKey=VPC,UsePreviousValue=true \
					                  ParameterKey=Cluster,UsePreviousValue=true \
					                  ParameterKey=Listener,UsePreviousValue=true \
					                  ParameterKey=Path,UsePreviousValue=true \
					                  ParameterKey=HealthCheckPath,UsePreviousValue=true \
					                  ParameterKey=HealthCheckProtocol,UsePreviousValue=true \
					                  ParameterKey=LoadBalancerProtocol,UsePreviousValue=true \
					                  ParameterKey=LoadBalancerPort,UsePreviousValue=true \
					                  ParameterKey=ListenerPriority,UsePreviousValue=true \
					                  ParameterKey=DockerImage,UsePreviousValue=true \
					                  ParameterKey=ContainerPort,UsePreviousValue=true \
					                  ParameterKey=ContainerMemory,UsePreviousValue=true \
					                  ParameterKey=ContainerName,UsePreviousValue=true \
					                  ParameterKey=ServiceFamily,UsePreviousValue=true \
					                  ParameterKey=LogGroup,UsePreviousValue=true"
```
Terraform is more straight forward. All you do is edit the Terraform plan in-place, review the changes and then apply them.  Here is the output from bumping up the number of ECS container instances from 2 to 3:

```
terraform show debug/proposed-changes.plan
  ~ module.ecs_service.aws_ecs_service.service
      desired_count: "2" => "3"


terraform apply -refresh=true -lock=true -auto-approve=true -input=false debug/proposed-changes.plan
module.ecs_service.aws_ecs_service.service: Modifying... (ID: arn:aws:ecs:us-east-2:387188308760:service/Terraform)
  desired_count: "2" => "3"
module.ecs_service.aws_ecs_service.service: Modifications complete after 0s (ID: arn:aws:ecs:us-east-2:387188308760:service/Terraform)

Apply complete! Resources: 0 added, 1 changed, 0 destroyed.
```

Compare the source of the link:terraform/ecs-service/debug/plan.tf[Terraform version] to the link:cloudformation/ecs-service/scripts/update-stack.sh[CloudFormation version] and see which you prefer.

=== Create the entire stack using modules
Terraform has good story for this one. In fact, there is the https://registry.terraform.io/[Terraform Module Registry] where the community can share "recipes" for assembling different pieces of infrastructure.  The Terraform code we've used so far have been expressed in terms of modules so assembling them into a single file is straight forward.

CloudFormation has the notion of "nested stacks" where a master file imports and invokes the child modules.  Unlike Terraform, there isn't a registry of community modules.  All the files have to live in S3, which makes deployments a little less convenient and requires an additional step to continually move files from source control into a bucket.

Compare the source of the link:terraform/composability/debug/plan.tf[Terraform version] to the link:cloudformation/ecs-service/scripts/update-stack.sh[CloudFormation version] and see which you prefer.

== License and Credits
This project is licensed under the https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode[Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License].
